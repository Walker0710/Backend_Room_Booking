package gmail

import (
	"log"
	"time"
	"encoding/base64"
	"fmt"
	"strings"

	"Backend_Room_Booking/database"
	"google.golang.org/api/gmail/v1"
)

func ProcessIncomingEmails(service *gmail.Service) {
	for {
		emailID, err := checkForNewEmails(service, "room-booking")
		if err == nil {
			processEmail(service, emailID)
		} else {
			log.Printf("Error checking for new emails: %v", err)
		}
		time.Sleep(30 * time.Second) 
	}
}

func processEmail(service *gmail.Service, emailID string) {
	sender, subject, body, err := getEmailDetails(service, emailID)
	if err != nil {
		log.Printf("Failed to process email: %v", err)
		return
	}

	log.Printf("Processing email with subject: %s", subject)
	
	if strings.Contains(sender, "lambda.iith.ac.in") || strings.Contains(sender, "kludge.iith.ac.in") {
		if strings.Contains(strings.ToLower(body), "generated by da") {
			err := forwardEmail(service, emailID, "fic.sa@iith.ac.in")
			if err != nil {
				log.Printf("Failed to forward email to fic.sa@iith.ac.in: %v", err)
			}
		}
	} else if strings.Contains(sender, "fic.sa@iith.ac.in") {
		if strings.Contains(strings.ToLower(body), "approved") {
			err := database.UpdateRoomStatus("roomID", "booked")
			if err != nil {
				log.Printf("Failed to update room status: %v", err)
			}

			err = forwardEmail(service, emailID, "roombooking@iith.ac.in")
			if err != nil {
				log.Printf("Failed to forward email to roombooking@iith.ac.in: %v", err)
			}
		}
	} else if strings.Contains(sender, "roombooking@iith.ac.in") {
		if strings.Contains(strings.ToLower(body), "we have booked") {
			err := forwardEmail(service, emailID, "cso@iith.ac.in")
			if err != nil {
				log.Printf("Failed to forward email to cso@iith.ac.in: %v", err)
			}
		}
	}
}

func getEmailDetails(service *gmail.Service, emailID string) (string, string, string, error) {
	msg, err := service.Users.Messages.Get("me", emailID).Do()
	if err != nil {
		return "", "", "", fmt.Errorf("failed to get email: %v", err)
	}

	var sender, subject string
	for _, header := range msg.Payload.Headers {
		if header.Name == "From" {
			sender = header.Value
		} else if header.Name == "Subject" {
			subject = header.Value
		}
	}

	var emailBody string
	if msg.Payload != nil && msg.Payload.Parts != nil {
		for _, part := range msg.Payload.Parts {
			if part.Body != nil && part.Body.Data != "" {
				data, err := base64.URLEncoding.DecodeString(part.Body.Data)
				if err == nil {
					emailBody += string(data)
				}
			}
		}
	} else if msg.Payload.Body != nil && msg.Payload.Body.Data != "" {
		data, err := base64.URLEncoding.DecodeString(msg.Payload.Body.Data)
		if err == nil {
			emailBody = string(data)
		}
	}

	return sender, subject, emailBody, nil
}

func checkForNewEmails(service *gmail.Service, label string) (string, error) {
	response, err := service.Users.Messages.List("me").LabelIds(label).MaxResults(1).Do()
	if err != nil {
		return "", fmt.Errorf("unable to retrieve messages: %v", err)
	}

	if len(response.Messages) == 0 {
		return "", nil 
	}

	return response.Messages[0].Id, nil 
}

func forwardEmail(service *gmail.Service, emailID string, recipient string) error {
	msg, err := service.Users.Messages.Get("me", emailID).Do()
	if err != nil {
		return fmt.Errorf("unable to retrieve the message: %v", err)
	}

	forwardedMessage := fmt.Sprintf("From: %s\nTo: %s\nSubject: Fwd: %s\n\n%s",
		msg.Payload.Headers[0].Value, // Original sender
		recipient,                    // Forwarding to this email
		msg.Payload.Headers[1].Value, // Original subject
		msg.Snippet,                  // Original message snippet or body
	)

	encodedMessage := base64.URLEncoding.EncodeToString([]byte(forwardedMessage))

	newMsg := &gmail.Message{
		Raw: encodedMessage,
	}

	_, err = service.Users.Messages.Send("me", newMsg).Do()
	if err != nil {
		return fmt.Errorf("unable to forward the message: %v", err)
	}

	return nil
}

